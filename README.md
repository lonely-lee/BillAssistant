# 账单助手
- 解析支付宝账单、微信账单、京东账单

## 账单分析
支付渠道有以下多个：
- 花呗
- 余额宝
- 微信钱包
- 京东白条
- 交通银行卡
- 招商信用卡
花呗还款可来源于余额宝、交通银行卡；
微信钱包来源于交通银行卡；
招商信用卡还款来源于交通银行卡；
购物渠道有以下：
1. 商户使用支付宝付款
2. 商户使用微信付款
3. 拼多多
4. 抖音商城
5. 闲鱼
6. 京东
7. ......

支付宝账单覆盖了 **花呗** 、 **余额宝**
微信账单覆盖了 **微信钱包**
京东账单覆盖了 京东上的购物：**微信钱包、京东白条、银行卡等等**查看是否与其他两个有重复？
招商信用卡账单覆盖了 


# `conda` 环境创建
- `conda create -n pyBillEnv python=3.13.5`

# 后续计划
## 进一步清洗数据
 - 完成 交易方式、交易状态、交易类型 的统一
 - 清洗方法：
 为了统一不同来源账单（支付宝、微信、京东）的交易类型，并将其归类为预定义的统一分类（如“交通出行”、“餐饮美食”等），可以采用以下结构化的方法来实现：

---

### **1. 预定义统一分类**
首先明确需要统一的交易类型分类：

```python
UNIFIED_CATEGORIES = {
    "交通出行",
    "餐饮美食",
    "投资理财",
    "生活开支",
    "日用百货",
    "文化休闲",
    "鞋帽服饰",
    "餐饮零食",
    "消费还款",
    "其他"
}
```

---

### **2. 分析各来源的原始交易类型**
针对每个账单来源（支付宝、微信、京东），分析其原始交易类型字段，并建立映射规则。例如：

- **支付宝**：可能包含“餐饮”、“购物”、“生活缴费”、“信用卡还款”等。
- **微信**：可能包含“餐饮美食”、“交通出行”、“生活服务”、“红包转账”等。
- **京东**：可能包含“数码”、“家居”、“食品”、“服饰”等。

---

### **3. 建立映射规则**
为每个来源建立一个映射字典，将原始交易类型映射到统一分类。例如：

```python
MAPPING_RULES = {
    "支付宝": {
        "餐饮": "餐饮美食",
        "购物": "日用百货",
        "生活缴费": "生活开支",
        "信用卡还款": "消费还款",
        "投资理财": "投资理财",
        "交通出行": "交通出行"
    },
    "微信": {
        "餐饮美食": "餐饮美食",
        "交通出行": "交通出行",
        "生活服务": "生活开支",
        "红包转账": "其他",
        "投资理财": "投资理财"
    },
    "京东": {
        "数码": "日用百货",
        "家居": "日用百货",
        "食品": "餐饮美食",
        "服饰": "鞋帽服饰",
        "图书": "文化休闲",
        "投资理财": "投资理财"
    }
}
```

---

### **4. 编写统一映射函数**
编写一个函数，根据账单来源和原始交易类型，返回统一分类：

```python
def unify_transaction_type(source, raw_type):
    """
    统一交易类型
    :param source: 账单来源（如 '支付宝', '微信', '京东'）
    :param raw_type: 原始交易类型
    :return: 统一后的分类
    """
    # 如果来源不在映射规则中，返回 '其他'
    if source not in MAPPING_RULES:
        return "其他"
    
    # 获取该来源的映射规则
    mapping = MAPPING_RULES[source]
    
    # 如果原始类型在映射规则中，返回对应的统一分类
    if raw_type in mapping:
        return mapping[raw_type]
    
    # 否则返回 '其他'
    return "其他"
```

---

### **5. 处理特殊情况**
#### **5.1 多关键词匹配**
如果原始交易类型字段中包含多个关键词（如“数码-电子产品”），可以通过正则匹配或关键词提取来处理：

```python
def extract_keyword(raw_type):
    """
    提取原始交易类型中的关键词
    """
    keywords = ["餐饮", "交通", "投资", "生活", "日用", "文化", "服饰", "零食", "还款"]
    for keyword in keywords:
        if keyword in raw_type:
            return keyword
    return None
```

#### **5.2 动态扩展映射规则**
对于未覆盖的交易类型，可以动态扩展映射规则，或记录到“其他”类别中：

```python
def dynamic_unify_transaction_type(source, raw_type, custom_mapping=None):
    if custom_mapping is None:
        custom_mapping = {}
    
    # 合并默认规则和自定义规则
    mapping = MAPPING_RULES.get(source, {})
    mapping.update(custom_mapping)
    
    if raw_type in mapping:
        return mapping[raw_type]
    
    return "其他"
```

---

### **6. 示例应用**
#### **6.1 示例数据**
```python
data = [
    {"source": "支付宝", "transaction_type": "餐饮"},
    {"source": "微信", "transaction_type": "生活服务"},
    {"source": "京东", "transaction_type": "食品"},
    {"source": "京东", "transaction_type": "数码"},
    {"source": "支付宝", "transaction_type": "信用卡还款"}
]
```

#### **6.2 应用统一映射函数**
```python
for item in data:
    unified_type = unify_transaction_type(item["source"], item["transaction_type"])
    print(f"来源: {item['source']}, 原始类型: {item['transaction_type']} → 统一类型: {unified_type}")
```

#### **6.3 输出结果**
```
来源: 支付宝, 原始类型: 餐饮 → 统一类型: 餐饮美食
来源: 微信, 原始类型: 生活服务 → 统一类型: 生活开支
来源: 京东, 原始类型: 食品 → 统一类型: 餐饮美食
来源: 京东, 原始类型: 数码 → 统一类型: 日用百货
来源: 支付宝, 原始类型: 信用卡还款 → 统一类型: 消费还款
```

---

### **7. 验证与优化**
- **验证**：通过测试数据验证映射规则的准确性。
- **优化**：根据实际数据调整映射规则，例如：
  - 将“京东-图书”归类为“文化休闲”。
  - 将“微信-红包转账”归类为“其他”。
- **扩展**：支持更多来源（如银行账单、花呗、白条等）。

---

### **8. 最终实现**
通过上述步骤，可以将不同来源的交易类型统一为预定义分类，便于后续数据分析和可视化。完整的代码如下：

```python
UNIFIED_CATEGORIES = {
    "交通出行", "餐饮美食", "投资理财", "生活开支", "日用百货",
    "文化休闲", "鞋帽服饰", "餐饮零食", "消费还款", "其他"
}

MAPPING_RULES = {
    "支付宝": {
        "餐饮": "餐饮美食",
        "购物": "日用百货",
        "生活缴费": "生活开支",
        "信用卡还款": "消费还款",
        "投资理财": "投资理财",
        "交通出行": "交通出行"
    },
    "微信": {
        "餐饮美食": "餐饮美食",
        "交通出行": "交通出行",
        "生活服务": "生活开支",
        "红包转账": "其他",
        "投资理财": "投资理财"
    },
    "京东": {
        "数码": "日用百货",
        "家居": "日用百货",
        "食品": "餐饮美食",
        "服饰": "鞋帽服饰",
        "图书": "文化休闲",
        "投资理财": "投资理财"
    }
}

def unify_transaction_type(source, raw_type):
    if source not in MAPPING_RULES:
        return "其他"
    mapping = MAPPING_RULES[source]
    return mapping.get(raw_type, "其他")
```

---

### **9. 扩展建议**
- **支持模糊匹配**：使用正则表达式或关键词提取（如 `re.search`）处理复杂交易类型字段。
- **动态配置**：将映射规则存储在外部文件（如 JSON、YAML）中，便于动态更新。
- **异常处理**：对缺失值（`NaN`）或非法类型进行处理，避免程序崩溃。

通过以上方法，可以高效地将不同来源的交易类型统一为标准化分类，为后续数据分析提供一致的数据基础。
